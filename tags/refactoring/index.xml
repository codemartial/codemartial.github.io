<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>refactoring on Tahir Hashmi</title><link>https://tahirhashmi.com/tags/refactoring/</link><description>Recent content in refactoring on Tahir Hashmi</description><generator>Hugo -- gohugo.io</generator><language>en-GB</language><managingEditor>mail@tahirhashmi.com (Tahir Hashmi)</managingEditor><webMaster>mail@tahirhashmi.com (Tahir Hashmi)</webMaster><lastBuildDate>Wed, 23 Jan 2013 14:15:14 +0000</lastBuildDate><atom:link href="https://tahirhashmi.com/tags/refactoring/index.xml" rel="self" type="application/rss+xml"/><item><title>The Compiler as a Refactoring Aid</title><link>https://tahirhashmi.com/posts/2013/01/23/the-compiler-as-a-refactoring-aid/</link><pubDate>Wed, 23 Jan 2013 14:15:14 +0000</pubDate><author>mail@tahirhashmi.com (Tahir Hashmi)</author><guid>https://tahirhashmi.com/posts/2013/01/23/the-compiler-as-a-refactoring-aid/</guid><description>Recently, I sat down to refactor a Go application with a high-level design objective in place. The application had two conceptually separate entities implemented in different files but mashed into a single package. I needed to separate them out into their own packages. I wasn’t using an IDE — just Emacs with basic formatting and non-contextual auto-complete aids.
I started out by creating a new directory for the package to be split out and moved the files that contained most of the relevant code into that directory, without thinking of the consequences.</description></item></channel></rss>