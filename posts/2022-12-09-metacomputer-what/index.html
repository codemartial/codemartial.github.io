<!doctype html><html lang=en-gb><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>The MetaComputer™ (Part "What" of 3), by Tahir Hashmi</title><meta name=description content="The MetaComputer™ is a computing model that simplifies modern cloud-native distributed application development. This article explores its features and functionality"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link rel=canonical href=https://tahirhashmi.com/posts/2022-12-09-metacomputer-what/><meta property="og:title" content="The MetaComputer™ (Part &#34;What&#34; of 3)"><meta property="og:description" content="The MetaComputer™ is a computing model that simplifies modern cloud-native distributed application development. This article explores its features and functionality"><meta property="og:type" content="article"><meta property="og:url" content="https://tahirhashmi.com/posts/2022-12-09-metacomputer-what/"><meta property="og:image" content="https://tahirhashmi.com/MetaComputerIcon.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-09T11:11:40+07:00"><meta property="article:modified_time" content="2023-04-09T23:03:28+07:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tahirhashmi.com/MetaComputerIcon.png"><meta name=twitter:title content="The MetaComputer™ (Part &#34;What&#34; of 3)"><meta name=twitter:description content="The MetaComputer™ is a computing model that simplifies modern cloud-native distributed application development. This article explores its features and functionality"><meta itemprop=name content="The MetaComputer™ (Part &#34;What&#34; of 3)"><meta itemprop=description content="The MetaComputer™ is a computing model that simplifies modern cloud-native distributed application development. This article explores its features and functionality"><meta itemprop=datePublished content="2022-12-09T11:11:40+07:00"><meta itemprop=dateModified content="2023-04-09T23:03:28+07:00"><meta itemprop=wordCount content="1646"><meta itemprop=image content="https://tahirhashmi.com/MetaComputerIcon.png"><meta itemprop=keywords content><link rel=alternate type=application/rss+xml href=https://tahirhashmi.com/posts/index.xml title="Tahir Hashmi"><link rel=stylesheet href=/assets/css/main.min.927de649eb6c5aae9b85634e0f926bbbd9d715a4e4589fd078f19dfbbd8ff7c1.css media=all><link rel=preload as=font href=/fonts/Probert.woff2 type=font/woff2 crossorigin=anonymous><link rel=preload as=font href=/fonts/ProbertBold.woff2 type=font/woff2 crossorigin=anonymous><link rel=preload as=font href=/fonts/Oxanium.woff2 type=font/woff2 crossorigin=anonymous><link rel=preload as=font href=/fonts/BerkeleyMonoVariable-Regular.woff2 type=font/woff2 crossorigin=anonymous><script defer src=/assets/js/main.min.35e33a864dbe04f338d5c5bb84090b1891b3f1dd3c2b651aa0317abcffc176b5.js></script></head><body class=page><div id=headline><h1>The MetaComputer™ (Part "What" of 3)</h1></div><div id=content><main><article><time datetime="2022-12-09 11:11:40 +0700 +0700" itemprop=datePublished>December 9, 2022</time><p>In <a href=/posts/2022-11-27-metacomputer-why>part &ldquo;Why&rdquo;</a> of this series that appeared previously, I talked about the need for a new computing model that simplifies modern cloud-native distributed application development. In this part, I&rsquo;ll go into some details of what this new computing model should be and what it should provide.</p><h2 id=who-is-the-metacomputer-for>Who Is the MetaComputer™ For?</h2><p>You would have figured by now that we&rsquo;re talking about a computing model for programmers who develop cloud-native distributed applications. But what does that mean?</p><p>The MetaComputer™ would be useful for programmers who develop connected applications, i.e. applications that are accessible over the network rather than being invoked as standalone executables or libraries. The key properties of these applications are:</p><ul><li>they expose their functionality through network endpoints (REST, gRPC, GraphQL, Messaging&mldr; )</li><li>they need to respond whenever a network client invokes them<ul><li>they may be running continuously in a wait loop</li><li>they may be terminated when clients disconnect and respawn when clients connect</li></ul></li><li>they handle persistent state that outlives the application process execution. i.e. even if the application is terminated, the data it operates on remains available for future use</li><li>they run on elastic compute resources, i.e. they may be deployed to as few or as many computers<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> or VMs as needed to satisfy the number of clients invoking them but not more</li><li>they are parallelised, i.e. multiple instances of these applications may be running at the same time, accessing the same persistent data</li><li>they usually work with other connected applications as a group to provide end user functionality (e.g. microservices)</li><li>they are heavily instrumented to provide computation and business execution data for subsequent analysis. i.e. they support the build-measure-learn development cycle.</li></ul><h2 id=what-does-the-metacomputer-provide>What Does the MetaComputer™ Provide?</h2><p>Now that we understand what kind of applications we need to be able to build on the MetaComputer™, we can start asking for functionality that the model should handle on its own, rather than requiring the programmer to be explicit about.</p><p>The MetaComputer™ must provide the following:</p><h3 id=service-programming-constructs>Service Programming Constructs</h3><ul><li>Native support for services<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> as a programming construct<ul><li>transparent network daemons, wire format conversion, stubs and skeletons, service discovery</li><li>user-to-service / service-to-service authentication and authorization</li></ul></li><li>Well defined resiliency model for interacting services</li><li>Programming constructs for service integration through<ul><li>sychronous request/response</li><li>asynchronous request/callback</li><li>bidirectional streaming</li><li>events and actors</li></ul></li><li>Persistence aware programming and native support for durable datatypes</li><li>Language level support for key architectural patterns (e.g. <abbr title="Command Query Responsibility Segregation">CQRS</abbr>, Event Sourcing, Actors, Workflows, etc.)</li><li>Built-in extensible observability stack with logs, monitors, profilers and pre-defined/user-defined metrics</li></ul><h3 id=metacomputing-environment>MetaComputing Environment</h3><p>The primary concern of a developer is to get the code they have written to execute in a computing environment. On top of that, they need to be able to get feedback from the environment about the code&rsquo;s performance and tools to troubleshoot unexpected program behaviour.</p><p>Developers aren&rsquo;t the only people that interact with a computing environment. A significant improvement to basic computing models can come in the area of state management and data driven intelligence. Following is the minimal list of built-in features that a MetaComputer™ must support</p><ul><li>MetaCompiler™<ul><li>Compiles MetaComputer™ programs into distributed service topologies</li><li>Provisions networks and infrastructure for the compiled service ecosystem</li></ul></li><li>Built-in support for managing versions and environments</li><li>SuperState™<ul><li>Logically consolidated persistent data storage</li><li><abbr title="Change Data Capture">CDC</abbr> and data aggregation</li><li>Out-of-the-box analytics over persistent data types</li><li>First class programming support for experimentation branches and experiment analysis</li></ul></li><li>Managed (serverless) runtime environment with auto-scaling</li></ul><p><figure><img $destination src=https://live.staticflickr.com/65535/52561426214_9dfe93b7da_o.png alt="MetaComputer™ Schematic" width=100% style=aspect-ratio:.7074422583404619><figcaption>MetaComputer™ Schematic</figcaption></figure></p><h3 id=next-generation-ecosystem>Next Generation Ecosystem</h3><p>Contemporary software distribution is predominantly through source code integration (library dependencies) or as SaaS. There was a time when distributing commercial software through precompiled binary libraries was quite common but it&rsquo;s no longer acceptable at large, compared to open source software distribution. Unfortunately, open source doesn&rsquo;t work very well for commercial vendors which has led to monetisation either through support services &ndash; which only works for monetising through enterprise customers &ndash; or through SaaS . SaaS, however, doesn&rsquo;t work very well for customers due to unnecessary network dependencies, loss of control over data fencing and single-vendor dependency.</p><p>A cloud-native programming environment brings about the opportunity to change software integration and distribution models. It can lead to a new distribution model that brings the best of both worlds (source integration and SaaS). This new model can support:</p><ul><li>Secure code sharing and distribution, resilient to supply-chain attacks</li><li>Install tracking and monetization for authors of proprietary as well as open source code</li><li>Open standards for enabling competition and differentiation among providers of metacomputing environment implementations</li><li>Broadly uniform pricing structure across metacomputing providers with different rate cards</li><li>Ability to switch across metacomputing providers by simply redeploying (eliminate cloud/SaaS vendor lock-in)</li></ul><h2 id=what-the-metacomputer-isnt>What the MetaComputer™ Isn&rsquo;t</h2><p>At this point, one might think that we&rsquo;re just looking for an enhancement over some existing technology. However, that is not the case. I ended the previous article talking about why Apache Mesos or Kubernetes are not the computing model we are looking for. Here I elaborate a bit more on the conceptual differences.</p><h3 id=not-a-supercomputer>Not a Supercomputer</h3><p>Apache Mesos originated from the cluster computing / supercomputing / <abbr title="High Performance Computing">HPC</abbr> background. The main concern in that environment is to allow running singular applications that place extreme demands on computing power. Think climate simulations involving particle physics etc.</p><p>A supercomputing model then is all about abstracting a collection of many many interconnected computers as one humongous computer with the sum total of all the computers&rsquo; CPU power, memory and disk space.</p><p>That&rsquo;s not the kind of abstraction that a typical service developer really wants. Most service backends are applications with modest resource requirements for a single business process but they run many instances of the same business process in parallel.</p><h3 id=not-an-orchestrator-or-iaas>Not an Orchestrator or IaaS</h3><p>Kubernetes, Docker Swarm and similar tools are a much more appropriate interface for managing the kind of applications we&rsquo;re interested in developing.</p><p>They take the underlying cluster of available computers and rather than summing them up into one giant conglomeration, they divvy up the individual computers&rsquo; resources into smaller logical chunks. Then they take the applications along with their resource requirement specifications and deploy those applications on to these chunks.</p><p>They go a step further and recognise that some applications can be run as &ldquo;services&rdquo; &ndash; a set of identical instances of the application all running in parallel under a load balancer that evenly distributes instances of business tasks across these instances.</p><p>Where the orchestrators fall short is in the amount of operational concerns that they require developers to become aware of. That&rsquo;s why I previously mentioned that suggesting these orchestrators as a computing model is like suggesting LLVM to someone looking for a modern general purpose programming language. The level of abstraction is too low.</p><h3 id=not-paas--faas>Not PaaS / FaaS</h3><p>Platform as a Service (PaaS) is essentially IaaS with some of the common applications and operational support made available by the PaaS provider through their APIs.</p><p>An IaaS provider would give you access to computing resources, leaving it up to you to run your application and also any <em>supporting components</em> of that application. A PaaS provider would, at the very minimum, include applications required to for smooth operation of your main applications.</p><p>There&rsquo;s no limit to how many supporting applications a PaaS provider may bundle. Usually, PaaS providers include popular databases that they manage entirely on their own and only require you to access them via APIs or special client libraries in your code. Stretching the PaaS concept all the way takes you to Serverless computing, wherein you do not need to deal with any server provisioning, management or operations.</p><p>PaaS, especially Serverless PaaS, offloads a lot of infrastructure provisioning and management but unfortunately it doesn&rsquo;t move the conceptual needle much further beyond the IaaS model. As a developer you still need to know about all the components and you need to wire them together in code. The more abstracted the PaaS is (e.g. FaaS), the more tedious it becomes to code applications that don&rsquo;t strictly fit its model.</p><h3 id=not-low-code>Not &ldquo;Low Code&rdquo;</h3><p>As we&rsquo;ve gone through the &ldquo;nots&rdquo; above, we&rsquo;ve moved closer to the ideal MetaComputer™ model. However, we now must take a wide diversion into Low Code Land.</p><p>Low Code is a class of application development environments that comprise a lot of pre-developed functionality that you simply import and customise for your needs. Any functionality that is not covered by the customisation needs to be written in the regular (High Code?) way.</p><p>If programming were like sculpting, Low Code would be like assembling lego blocks. What we&rsquo;re looking for is the 3D Printer with swappable materials.</p><h2 id=what-is-the-metacomputer>What Is the MetaComputer™?</h2><p>We have come the long way round to finally define what a MetaComputer™ is.</p><blockquote><p>A MetaComputer™ is a computing model with an associated programming language and runtime for distributed applications.
The MetaComputer™ models elastic network services and abstracts their integration, change management and infrastructure.</p></blockquote><p>The layman definition may be</p><blockquote><p>A MetaComputer™ is a magical technology that makes modern software development 10x more effective, scalable and reliable in a cost-efficient way.</p></blockquote><p>Or maybe</p><blockquote><p>A computing foundation that present day programmers can develop their skills on to last through to the end of their careers, while the MetaComputer™ abstracts technology changes into ever improving implementations of the MetaComputing Environment.</p></blockquote><p>Phew! That&rsquo;s a lot to process in one go! By this point pretty much everyone I&rsquo;ve talked to about this shurgs their shoulders and wonders if it&rsquo;s even possible to implement such a system.</p><p>Well, that would take us to the upcoming <a href>Part &ldquo;How&rdquo;</a> of this series. That&rsquo;s going to take me a while to write. Meanwhile, if you believe you have some idea of how to make this happen, join the <a href=https://github.com/metacomputer target=_blank rel=noopener>MetaComputer™</a> organisation on Github.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>My definition of a &ldquo;computer&rdquo; is an independently bootable chassis with one or more CPUs, RAM, network interface(s) and some non-volatile storage. This also includes VMs, unless the exclusion is pertinent.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>A <strong>Service</strong> is an elastically scalable network API with specific calling conventions, attached <abbr title="Service Level Indicators|Objectives|Agreements">SL[I|O|A]s</abbr> and access permissions&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article><div style=display:flex;width:100%><div style=width:50%><p style=text-align:left>Previous Post:<br><a href=https://tahirhashmi.com/posts/2022-11-27-metacomputer-why/>The MetaComputer™ (Part "Why" of 3)</a></p></div><div style=width:50%><p style=text-align:right>Next Post:<br><a href=https://tahirhashmi.com/posts/x100v-review/>Fujifilm X100V Review: An Unfulfilled Dream</a></p></div></div></main></div><div id=sidebar><nav class=sidebar-nav><ul><li><a class=sidebar-nav-item href=/posts/ title=Articles>Articles</a></li><li><a class=sidebar-nav-item href=/about/ title=About>About</a></li><li><a class=sidebar-nav-item href=/photos/ title=Photos>Photos</a></li><li><a class=sidebar-nav-item href=/categories/opinion/ title=opinion>opinion</a></li><li><a class=sidebar-nav-item href=/categories/photography/ title=photography>photography</a></li><li><a class=sidebar-nav-item href=/categories/programming/ title=programming>programming</a></li><li><a class=sidebar-nav-item href=/categories/reviews/ title=reviews>reviews</a></li><li><a class=sidebar-nav-item href=/categories/technology/ title=technology>technology</a></li></ul><aside class=toc><h4>On this page</h4><nav id=TableOfContents><ul><li><a href=#who-is-the-metacomputer-for>Who Is the MetaComputer™ For?</a></li><li><a href=#what-does-the-metacomputer-provide>What Does the MetaComputer™ Provide?</a><ul><li><a href=#service-programming-constructs>Service Programming Constructs</a></li><li><a href=#metacomputing-environment>MetaComputing Environment</a></li><li><a href=#next-generation-ecosystem>Next Generation Ecosystem</a></li></ul></li><li><a href=#what-the-metacomputer-isnt>What the MetaComputer™ Isn&rsquo;t</a><ul><li><a href=#not-a-supercomputer>Not a Supercomputer</a></li><li><a href=#not-an-orchestrator-or-iaas>Not an Orchestrator or IaaS</a></li><li><a href=#not-paas--faas>Not PaaS / FaaS</a></li><li><a href=#not-low-code>Not &ldquo;Low Code&rdquo;</a></li></ul></li><li><a href=#what-is-the-metacomputer>What Is the MetaComputer™?</a></li></ul></nav></aside><div id=fastSearch><span id=cursor><input id=searchInput tabindex=0 placeholder=search></span><ul id=searchResults></ul></div></nav></div><div id=section2><p><a href=https://tahirhashmi.com/posts/>Articles</a></p></div><div id=logo><a href=/><svg id="svgLogo" baseProfile="full" xmlns="https://www.w3.org/2000/svg" viewBox="0 0 400 100" preserveAspectRatio="xMidYMid"><radialGradient id="logoGradient"><stop offset="30%" stop-color="#00ff80"/><stop offset="67%" stop-color="#00c000"/><stop offset="100%" stop-color="#606000"/></radialGradient><polygon points="0, 67 160, 0 200, 100 240, 0 400, 67 240, 33 200, 67 160, 33" fill="url(#logoGradient)"/></svg></a></div><div id=space><p>Tahir Hashmi</p></div><footer id=footer>mail@tahirhashmi.com
| <a href=https://flickr.com/photos/code_martial/>Flickr</a>
| <a href=https://github.com/codemartial>Github</a>
| <a href=https://www.linkedin.com/in/tahirhashmi>LinkedIn</a>
| <a href=https://twitter.com/code_martial>Twitter</a>
| <a href=https://tahirhashmi.com/posts/index.xml type=.mediatype.type rel=.rel>RSS</a> | &copy; 2022 Tahir Hashmi. All rights reserved.</footer><div class=splash></div><div class=glow></div></body></html>