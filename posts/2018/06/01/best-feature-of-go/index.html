<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>The Best Feature of Go by Tahir Hashmi</title><meta name=description content><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link rel=canonical href=https://tahirhashmi.com/posts/2018/06/01/best-feature-of-go/><link rel=alternate type=application/rss+xml href=https://tahirhashmi.com/index.xml><meta property="og:title" content="The Best Feature of Go"><meta property="og:description" content="I‚Äôve been programming since the late 90‚Äôs and I‚Äôve done quite a bit of coding in C, C++, a lot of it in PHP and some in Python as well. On the front-end I‚Äôve done some JavaScript and I‚Äôve also had the misfortune of programming in Java üòâ
I started programming in Go in 2012 and since then I haven‚Äôt wanted to program in any other language. I‚Äôve had a handful of large Go implementations across two companies and by now I have my own short list of favourite features."><meta property="og:type" content="article"><meta property="og:url" content="https://tahirhashmi.com/posts/2018/06/01/best-feature-of-go/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-06-01T10:12:41+00:00"><meta property="article:modified_time" content="2022-10-22T22:35:15+07:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="The Best Feature of Go"><meta name=twitter:description content="I‚Äôve been programming since the late 90‚Äôs and I‚Äôve done quite a bit of coding in C, C++, a lot of it in PHP and some in Python as well. On the front-end I‚Äôve done some JavaScript and I‚Äôve also had the misfortune of programming in Java üòâ
I started programming in Go in 2012 and since then I haven‚Äôt wanted to program in any other language. I‚Äôve had a handful of large Go implementations across two companies and by now I have my own short list of favourite features."><meta itemprop=name content="The Best Feature of Go"><meta itemprop=description content="I‚Äôve been programming since the late 90‚Äôs and I‚Äôve done quite a bit of coding in C, C++, a lot of it in PHP and some in Python as well. On the front-end I‚Äôve done some JavaScript and I‚Äôve also had the misfortune of programming in Java üòâ
I started programming in Go in 2012 and since then I haven‚Äôt wanted to program in any other language. I‚Äôve had a handful of large Go implementations across two companies and by now I have my own short list of favourite features."><meta itemprop=datePublished content="2018-06-01T10:12:41+00:00"><meta itemprop=dateModified content="2022-10-22T22:35:15+07:00"><meta itemprop=wordCount content="2515"><meta itemprop=keywords content="Go,Golang,programming,"><link rel=stylesheet href=/assets/css/main.min.aa291f4a1468fe8ac611dffbcaee5c517c3ccfe256bfcb86dc2838cffdd62694.css media=all></head><body class=page><div id=headline><h1>The Best Feature of Go</h1></div><div id=content><main><article><time datetime="2022-10-22 22:35:15 +0700 +0700" itemprop=datePublished>October 22, 2022</time><p>I‚Äôve been programming since the late 90‚Äôs and I‚Äôve done quite a bit of coding in C, C++, a lot of it in PHP and some in Python as well. On the front-end I‚Äôve done some JavaScript and I‚Äôve also had the misfortune of programming in Java üòâ</p><p>I started programming in Go in 2012 and since then I haven‚Äôt wanted to program in any other language. I‚Äôve had a handful of large Go implementations across two companies and by now I have my own short list of favourite features.</p><p>One of those features is not mentioned very often but it has changed things significantly for me, and that‚Äôs what I‚Äôm going to discuss here.</p><h2 id=the-good-features>The Good Features</h2><p>Without further ado, here‚Äôs the rundown to my top features of Go.</p><h3 id=compiler--syntax>Compiler & Syntax</h3><p>In terms of convenience of programming, compiled languages have been a bit difficult to handle. Especially languages like C++ or Java that are almost impossible to write in without some kind of IDE Support.</p><p>Go on the other hand is very concise and simple. Things like type inference etc. make it very easy to code in ‚Äì it almost feels like a scripting language. The error messages from the compiler are also very helpful, unlike, say, the C++ STL error messages.</p><p>The language syntax and conventions focus a lot on intent rather than expression. If you look at languages like Perl or Scala, you‚Äôll come across many operators or syntactic sugar to express some logic, which is not the case with Go. While it‚Äôs very nice to write with those operators, it makes things very difficult to read later on. Go uses very straightforward imperative syntax ‚Äì just clearly state what you intend to do with a few keywords and operators.</p><p>Another interesting aspect about Go is that if the programs compile, they usually work. This is one of the properties of well designed languages. I first observed it with Python, where if I wrote a program it usually worked correctly the first time more often than it did with C or C++ or PHP. This reduces the time to finish quite a lot.</p><p>Lastly, the performance and reliability you get from a Go program in the first hour or day of effort is phenomenal. Getting the same level of performance in, say, Java would take hours to optimise the code and figure out the features to use, etc. That makes Go a highly productive language.</p><h3 id=small-feature-set>Small Feature Set</h3><p>Go is only slightly bigger than C, and C is a very concise language. I remember when I was in college and I had to appear for a C programming exam. I read the Kernighan and Ritchie book cover to cover over the weekend and aced the test. That‚Äôs not something you can do if you want to learn C++ or Java or most other mainstream languages.</p><p>Because it‚Äôs small, Go is also very easy to learn and remember. All the features that are present in Go are <em>orthogonal</em> and <em>minimal</em>. Orthogonal means that you can combine any feature with any other feature in meaningful ways. So the number of things you can do with a small set of features is very large because the number of meaningful combinations of features is large. Minimal means that there are not too many different ways to do the same thing. This is unlike the Perl philosophy of TIMTOWTDI (there is more than one way to do it). In Go, as in Python, there‚Äôs only one good way to do something.</p><p>The net result of this is that there are very few ‚Äúknowledge islands‚Äù, unlike in large languages. With large languages like C++ or Java, you will find many programmers that are only familiar or comfortable with a subset of the language. There are very few people who know the entire language end-to-end. ‚ÄúKnowledge islands‚Äù make it very difficult for people to exchange ideas with each other if there‚Äôs insufficient overlap in knowledge between them.</p><h3 id=standardised-formatting>Standardised Formatting</h3><p>This is one of the most famous features of Go and it improves <em>accessibility</em> of code by an exponential factor. That in turn improves collaboration. When you see your code vs. your team member‚Äôs code it looks exactly the same. When you see code written in your team vs. code written in another team, it still looks the same. This reduces the psychological ‚Äúours‚Äù vs. ‚Äútheirs‚Äù cognitive barrier and one of the effects of this is in making open source code more accessible.</p><h3 id=sensible-unicode--strings>Sensible Unicode & Strings</h3><p>This is another feature I like a lot, though it doesn‚Äôt get talked about much. Go is one of the very few languages that get Unicode and strings right.</p><p>One of the things that I did back in 2003 was to implement <a href=http://xqueeze.sourceforge.net/introduction.shtml>a binary XML syntax</a> ‚Äì a more efficient XML serialisation format ‚Äì and I enjoyed using C++ strings library a lot for that. I could read bytes directly off a file and use all the string manipulation features to deal with them. That‚Äôs something I found missing in Java.</p><p>In Java if you want to do any kind of string manipulation ‚Äì say, parsing the first few bytes of a header or do substring matching , etc. ‚Äì you would first have to convert the bytes into strings. And strings are Unicode code points in Java. One of the consequences of which is that it‚Äôs not just inconvenient to program with, it‚Äôs also inefficient. Whenever you need to transform the bytes into strings, you also necessarily have to do a memory copy because the underlying data types are incompatible.</p><p>Go very cleverly uses UTF-8 representation of a string as the basis of its <code>string</code> type instead of Unicode code points. Perhaps it‚Äôs¬† because Rob Pike is the inventor of UTF-8, but it‚Äôs a very good design decision anyway. Since UTF-8 ubiquitous, it makes writing network programs a lot more convenient compared to, say, Java ‚Äì or Python 3 for that matter. I don‚Äôt know why Python 3 went the Java way.</p><h3 id=channels--goroutines>Channels & Goroutines</h3><p>Another headline feature of Go is, of course, Channels and Goroutines. It can be argued that Go did to concurrent programming what Java did to memory management ‚Äì make the respective task significantly safer and simpler in an industrial strength programming environment.</p><p>Go‚Äôs concurrency model is based on the formal theory of Hoare‚Äôs CSP (Communicating Sequential Processes) Model, and allows writing concurrent programs in a more declarative manner. Simply preceding a function call or method invocation with the <code>go</code> keyword causes it to execute in a concurrent context.</p><p>Channels allow unidirectional or bidirectional data exchange between goroutines with built-in blocking primitives for synchronising between senders and receivers. Unlike NodeJS or async Java frameworks, coordination through channels enables concurrent logic without the proliferation of callbacks, which become very difficult to understand and reason about as the size of code grows.</p><h3 id=select-statement><code>select</code> Statement</h3><p>The <code>select</code> statement is, I think, the party piece of Go‚Äôs concurrency features. It is a very simple, declarative way to combine multiple blocking events (channel reads or writes) and branch off some logic based on which of the events unblocks first.</p><p>It allows writing some of the most difficult concurrency patterns in an easy to understand and safe manner. Timeouts & cancellation, back-pressure, worker pools, etc. are easy to implement. Even more sophisticated synchronisation and scatter/gather logic is made possible with simplicity using <code>select</code>.</p><h2 id=intermission>Intermission</h2><p>With all of these wonderful features and some more that I‚Äôve not even covered, Go permanently altered my programming capabilities and the kind of programs I wrote.</p><p>The first production system I wrote in Go was a real-time multi-player game that earned over a million dollars in a year and ran on <em>just one server</em>, the other one being a warm stand-by.</p><p>Over the years I also developed/co-developed a user activity rate limiter, a reverse proxy, a micro-service simulator, a deployment orchestrator, an auto-scaler and even a <a href="https://www.youtube.com/watch?v=BTyCwWoI3NU">bespoke datastore</a>!</p><p>The best feature of Go, however, changed <em>the way I program</em>.</p><p>This feature that I‚Äôm going to talk about next acts as a stand-in for the user so you can code from the mindset of a user rather than a programmer. It improves documentation. It can be a very significant guide for improving the design and modularity of your program. It improves the speed and reliability of refactoring and debugging. It finds unnecessary or dysfunctional code, and it gives rapid feedback on performance characteristics of your program <em>as it is being developed</em>.</p><p>Can you guess what this feature is?</p><h2 id=go-test><code>go test</code></h2><p>Most people already know of <code>go test</code> as a built in unit testing framework that comes as part of a standard Go installation. Which, by itself, is a pretty significant improvement over many other languages where you need to make your own choice of a unit testing framework and then worry about making it work with the rest of the ecosystem like editors, build tools, reporting tools, etc.</p><p>However, there‚Äôs more to <code>go test</code> than meets the eye. Let‚Äôs look at what all <code>go test</code> can do for the programmer.</p><h3 id=design-phase-assistance-from-go-test>Design Phase Assistance from <code>go test</code></h3><p>The first point where <code>go test</code> can facilitate program development is by simulating the user of the program. Most of the time, when we start writing a program, we write a <code>main</code> function to ‚Äútry out‚Äù the program. A better way to do this in Go is to create a test file. If you‚Äôre writing a package <code>mypkg</code>, the test file should declare itself as <code>package mypkg&lt;b>_test&lt;/b></code>. This makes the test file an outsider to your package, so you need to import your package into the test file to access its functionality.</p><p>This little trick immediately allows you to switch roles between a developer and a user. It can guide your API design. It can help you decide what symbols to export and what symbols to keep private. By ditching <code>main</code> for a test package, you take the first step towards integrated testing. And, as they say, getting started is half the job done!</p><p>Another significant way that <code>go test</code> helps in program design is by forcing you to think about ease of testing. Monolithic, do-it-all functions are hard to test, so balancing your urge to implement with the need to test naturally leads to improved modularity and improved cohesion. As an example, when developing a micro-service, I typically use the following strategy:</p><ol><li><p>Implement all of the business logic as native APIs with native data structures ‚Äî this is the package whose unit tests exhaustively cover business logic testing</p></li><li><p>Implement data load/store from native data structures to database ‚Äî this package is devoted only to data handling and the unit tests only cover data transformations</p></li><li><p>Implement RPC (HTTP etc.) as a wrapper using the previous two packages ‚Äî for this package the tests only deal with request interpretation and response serialisation, not business logic</p></li></ol><p>Lastly, <code>go test</code> offers an excellent way to <a href=https://blog.golang.org/examples>write example code</a> that shows up in the <code>go doc</code> documentation at the appropriate places and is verified for correctness. If you want to document a function, just write <code>func Example<i>Function</i>() {‚Ä¶}</code> in a test file and this code will show up next to the documentation of the function, <code>Function</code>. Similarly write <code>func Example<i>Struct_Method</i>() {‚Ä¶}</code> to document a method, <code>Struct.Method()</code>. If you want to document a use case, write <code>func Example<i>_useCase</i>() {‚Ä¶}</code> to document an entire use case. Adding a block comment starting with <code>Output:</code> at the end of the example‚Äôs implementation will make <code>go test</code> execute the example and match its output to the comment so you know whether your example works. <code>go doc</code> would document the output as part of the example.</p><h3 id=implementation-assistance-from-go-test>Implementation Assistance from <code>go test</code></h3><p>If you write some straight-forward table driven tests for your package‚Äôs public API, those tests act as your compatibility guarantee while you‚Äôre refactoring things around. If they pass, your refactored package is still working as expected. You can organise your test functions into top-level tests that test out scenarios and have subtests within them to test more granular functionality.</p><p>If, after a refactoring change, your tests don‚Äôt compile, it‚Äôs a clear indication of changes in the package APIs. If the tests compile but fail, it indicates a change in functional behaviour of your package. The more granular the tests, the easier it is to locate the faulty change.</p><p><code>go test</code> not only helps with ensuring functional correctness but it also helps in verifying non-functional aspects. If you write concurrent tests and run the tests under a race detector ( <code>go test -race</code>), you‚Äôll be able to catch any data races that, if left undiscovered, can cause your program to crash while it‚Äôs running in production.</p><p>It is also possible to write some long running tests to verify deeper behaviours of your implementation. For example, my package <a href=https://github.com/codemartial/smartcb>smartcb</a> has a few long simulation tests that don‚Äôt execute by default but get enabled when invoked as <code>go test -tags sims</code>.</p><p>It is even possible to use <code>go test</code> to discover code bloat. Usually, you would run <code>go vet</code> and among other things, it will find unreachable code for you, that you can simply delete. However, this doesn‚Äôt cover all situations. One excellent property of writing exhaustive unit tests is that if you get a test coverage report and it‚Äôs not 100%, you are either not testing your code thoroughly enough or you have some code that is not testable because it represents a logically impossible scenario. This is a very powerful way to discover unused functions or types that otherwise keep accumulating as a piece of code goes through multiple maintenance cycles.</p><h3 id=performance-optimisation-from-go-test>Performance Optimisation from <code>go test</code></h3><p>One of the most powerful features of <code>go test</code> is the benchmarking infrastructure. The ability to monitor the performance characteristics of code as it is being developed and assess the impact of code changes on performance is a goldmine.</p><p>Just write a few benchmarks for top-level package APIs in your test files. Then, to find how fast the functions/methods are, run:</p><pre tabindex=0><code>go test -bench
</code></pre><p>To observe multi-core scalability, with various values of N, run:</p><pre tabindex=0><code>go test -bench -cpu N
</code></pre><p>To see what parts of your code are slow, run:</p><pre tabindex=0><code>go test -bench -cpuprofile
</code></pre><p>To see what parts of the code eat up memory, run:</p><pre tabindex=0><code>go test -bench -memprofile
</code></pre><p>Run <code>go test -bench</code> after every commit to find performance regressions if you are writing something performance sensitive.</p><p>Think that‚Äôs something too hard to do? Think again. Here‚Äôs a video that shows just how long it takes to test a non-trivial program, benchmark it for performance and analyse the benchmarks for performance issues.</p><h2 id=closing-thoughts>Closing Thoughts</h2><p>Having experienced the power of go test and its influence on my programming practice, the following statement sums up my view about it.</p><blockquote><p>Go test is like a programmer‚Äôs assistant. An Ironman‚Äôs Jarvis. A Batman‚Äôs Alfred.
It happens to run unit tests too.</p><p>‚Äî Yours Truly</p></blockquote><p>This post is based on <a href=https://youtu.be/CpcmtsxXuoE>my talk</a> at Tokopedia Tech-a-Break. Following are the accompanying slides.</p><p><a href=//www.slideshare.net/TahirHashmi5/the-best-feature-of-go-a-5-year-retrospective title="The Best Feature of Go ‚Äì A 5 Year Retrospective">The Best Feature of Go ‚Äì A 5 Year Retrospective</a> from <a href=https://www.slideshare.net/TahirHashmi5>Tahir Hashmi</a></p></article><hr><div style=display:flex;width:100%><div style=width:50%><p style=text-align:left>Previous Post:<br><a href=https://tahirhashmi.com/posts/2014/01/22/inheritance-semantics-in-go/>Inheritance Semantics in Go</a></p></div><div style=width:50%><p style=text-align:right>Next Post:<br><a href=https://tahirhashmi.com/posts/2019/01/19/5-competitive-advantages-in-technology/>5 Competitive Advantages in Technology</a></p></div></div></main></div><div id=sidebar><nav class=sidebar-nav><ul><li><a class=sidebar-nav-item href=/posts/ title=Articles>Articles</a></li><li><a class=sidebar-nav-item href=/about/ title=About>About</a></li><li><a class=sidebar-nav-item href=/photos/ title=Photos>Photos</a></li><li><a class=sidebar-nav-item href=/categories/photography/ title=photography>photography</a></li><li><a class=sidebar-nav-item href=/categories/programming/ title=programming>programming</a></li><li><a class=sidebar-nav-item href=/categories/reviews/ title=reviews>reviews</a></li><li><a class=sidebar-nav-item href=/categories/technology/ title=technology>technology</a></li></ul><aside class=toc><h4>On this page</h4><nav id=TableOfContents><ul><li><a href=#the-good-features>The Good Features</a><ul><li><a href=#compiler--syntax>Compiler & Syntax</a></li><li><a href=#small-feature-set>Small Feature Set</a></li><li><a href=#standardised-formatting>Standardised Formatting</a></li><li><a href=#sensible-unicode--strings>Sensible Unicode & Strings</a></li><li><a href=#channels--goroutines>Channels & Goroutines</a></li><li><a href=#select-statement><code>select</code> Statement</a></li></ul></li><li><a href=#intermission>Intermission</a></li><li><a href=#go-test><code>go test</code></a><ul><li><a href=#design-phase-assistance-from-go-test>Design Phase Assistance from <code>go test</code></a></li><li><a href=#implementation-assistance-from-go-test>Implementation Assistance from <code>go test</code></a></li><li><a href=#performance-optimisation-from-go-test>Performance Optimisation from <code>go test</code></a></li></ul></li><li><a href=#closing-thoughts>Closing Thoughts</a></li></ul></nav></aside></nav></div><div id=section2><p><a href=https://tahirhashmi.com/posts/>Articles</a></p></div><div id=logo><a href=/><svg id="svgLogo" baseProfile="full" xmlns="https://www.w3.org/2000/svg" viewBox="0 0 400 100" preserveAspectRatio="xMidYMid"><radialGradient id="logoGradient"><stop offset="30%" stop-color="#00ff80"/><stop offset="67%" stop-color="#00c000"/><stop offset="100%" stop-color="#606000"/></radialGradient><polygon points="0, 67 160, 0 200, 100 240, 0 400, 67 240, 33 200, 67 160, 33" fill="url(#logoGradient)"/></svg></a></div><div id=space><p>Tahir Hashmi</p></div><footer id=footer>mail@tahirhashmi.com
| <a href=https://flickr.com/photos/code_martial/>Flickr</a>
| <a href=https://github.com/codemartial>Github</a>
| <a href=https://www.linkedin.com/in/tahirhashmi>LinkedIn</a>
| <a href=https://twitter.com/code_martial>Twitter</a>
| <a href=https://tahirhashmi.com/index.xml>RSS</a>
| &copy; 2022 Tahir Hashmi. All rights reserved.</footer><div class=splash></div></body></html>