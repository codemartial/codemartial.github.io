<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>The Compiler as a Refactoring Aid by Tahir Hashmi</title><meta name=description content><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link rel=canonical href=https://tahirhashmi.com/posts/2013/01/23/the-compiler-as-a-refactoring-aid/><link rel=alternate type=application/rss+xml href=https://tahirhashmi.com/index.xml><meta property="og:title" content="The Compiler as a Refactoring Aid"><meta property="og:description" content="Recently, I sat down to refactor a Go application with a high-level design objective in place. The application had two conceptually separate entities implemented in different files but mashed into a single package. I needed to separate them out into their own packages. I wasn’t using an IDE — just Emacs with basic formatting and non-contextual auto-complete aids.
I started out by creating a new directory for the package to be split out and moved the files that contained most of the relevant code into that directory, without thinking of the consequences."><meta property="og:type" content="article"><meta property="og:url" content="https://tahirhashmi.com/posts/2013/01/23/the-compiler-as-a-refactoring-aid/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2013-01-23T14:15:14+00:00"><meta property="article:modified_time" content="2022-10-22T22:22:50+07:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="The Compiler as a Refactoring Aid"><meta name=twitter:description content="Recently, I sat down to refactor a Go application with a high-level design objective in place. The application had two conceptually separate entities implemented in different files but mashed into a single package. I needed to separate them out into their own packages. I wasn’t using an IDE — just Emacs with basic formatting and non-contextual auto-complete aids.
I started out by creating a new directory for the package to be split out and moved the files that contained most of the relevant code into that directory, without thinking of the consequences."><meta itemprop=name content="The Compiler as a Refactoring Aid"><meta itemprop=description content="Recently, I sat down to refactor a Go application with a high-level design objective in place. The application had two conceptually separate entities implemented in different files but mashed into a single package. I needed to separate them out into their own packages. I wasn’t using an IDE — just Emacs with basic formatting and non-contextual auto-complete aids.
I started out by creating a new directory for the package to be split out and moved the files that contained most of the relevant code into that directory, without thinking of the consequences."><meta itemprop=datePublished content="2013-01-23T14:15:14+00:00"><meta itemprop=dateModified content="2022-10-22T22:22:50+07:00"><meta itemprop=wordCount content="599"><meta itemprop=keywords content="Go,Golang,refactoring,"><link rel=stylesheet href=/assets/css/main.min.aa291f4a1468fe8ac611dffbcaee5c517c3ccfe256bfcb86dc2838cffdd62694.css media=all></head><body class=page><div id=headline><h1>The Compiler as a Refactoring Aid</h1></div><div id=content><main><article><time datetime="2022-10-22 22:22:50 +0700 +0700" itemprop=datePublished>October 22, 2022</time><p>Recently, I sat down to refactor a Go application with a high-level design objective in place. The application had two conceptually separate entities implemented in different files but mashed into a single package. I needed to separate them out into their own packages. I wasn’t using an IDE — just Emacs with basic formatting and non-contextual auto-complete aids.</p><p>I started out by creating a new directory for the package to be split out and moved the files that contained most of the relevant code into that directory, without thinking of the consequences. I could just invoke the compiler and let it guide me through the process of fitting the pieces of the puzzle together. One of the nice features of modern compilers is that they don’t continue dumping out errors beyond a limit. This allows fixing a program in small steps, going by the changes in errors produced by the compilers.</p><p>The first thing the compiler told me about was all the variables that got hidden due to things being moved into a new package. While working that out, it also helped me discover that the interface being used by Entity A to access Entity B (one that moved to the new package) only had private methods. Whoa! This is a semantic issue, which automatic refactoring tools that help with moving code around or creating new classes etc., can’t deal with.</p><p>Next, I tried to access the invisible variables by importing the new package, but the compiler complained, “ <code>import cycle not allowed</code>“. Nice. I could work out the dependency tree and information passing after having separated the packages, instead of first figuring out the dependencies and then moving code. See how the compiler is guiding me toward better design as well?</p><p>At this point, some of you might think this is a daft way of going about refactoring and I should have worked out the entire design on paper before touching the code. But is it daft, really? Here’s what refactoring guided by a “good” compiler is allowing me to do:</p><ul><li><p>It lets me access code as I’m working out a design. Any design or refactoring done without referring to code is prone to be erroneous.</p></li><li><p>It ensures that I don’t miss out on a code path. The compiler checks more code paths than I can bother to follow in my mind and it reveals problems with those paths.</p></li><li><p>It allows me to do top-down refactoring. I make the big, disruptive change that satisfies my design objective first, and the compiler guides me through the details of making that change work.</p></li><li><p>It allows me to evaluate the impact of different design decisions on code immediately, instead of having to guess.</p></li><li><p>The best thing, though, is that <em>I reduce the mental context to be carried</em>. This is a significant benefit since it allows me to refactor in smaller sessions. I can commit partially fixed code and carry on from where I left the last time. I don’t need to remember what needed to be done because the compiler reminds me about it.</p></li></ul><p>I followed roughly the same refactoring practices while coding with interpreted languages, but having to execute the program to find errors added a level of complexity, not to mention more of print/step-through debugging. It also left more for manual code inspection to ensure all corners were covered since having 100% code coverage in tests is not always feasible.</p><p>Using a compiler that does static analysis just improves the whole process considerably. Using a compiler along with a high productivity language like Go makes it fun as well!</p></article><hr><div style=display:flex;width:100%><div style=width:50%><p style=text-align:left>Previous Post:<br><a href=https://tahirhashmi.com/posts/2013/01/21/go-workshop/>Go Workshop</a></p></div><div style=width:50%><p style=text-align:right>Next Post:<br><a href=https://tahirhashmi.com/posts/2013/10/28/mapping-oo-interfaces-to-rest/>Mapping OO Interfaces to REST</a></p></div></div></main></div><div id=sidebar><nav class=sidebar-nav><ul><li><a class=sidebar-nav-item href=/posts/ title=Articles>Articles</a></li><li><a class=sidebar-nav-item href=/about/ title=About>About</a></li><li><a class=sidebar-nav-item href=/photos/ title=Photos>Photos</a></li><li><a class=sidebar-nav-item href=/categories/photography/ title=photography>photography</a></li><li><a class=sidebar-nav-item href=/categories/programming/ title=programming>programming</a></li><li><a class=sidebar-nav-item href=/categories/reviews/ title=reviews>reviews</a></li><li><a class=sidebar-nav-item href=/categories/technology/ title=technology>technology</a></li></ul><aside class=toc><h4>On this page</h4><nav id=TableOfContents></nav></aside></nav></div><div id=section2><p><a href=https://tahirhashmi.com/posts/>Articles</a></p></div><div id=logo><a href=/><svg id="svgLogo" baseProfile="full" xmlns="https://www.w3.org/2000/svg" viewBox="0 0 400 100" preserveAspectRatio="xMidYMid"><radialGradient id="logoGradient"><stop offset="30%" stop-color="#00ff80"/><stop offset="67%" stop-color="#00c000"/><stop offset="100%" stop-color="#606000"/></radialGradient><polygon points="0, 67 160, 0 200, 100 240, 0 400, 67 240, 33 200, 67 160, 33" fill="url(#logoGradient)"/></svg></a></div><div id=space><p>Tahir Hashmi</p></div><footer id=footer>mail@tahirhashmi.com
| <a href=https://flickr.com/photos/code_martial/>Flickr</a>
| <a href=https://github.com/codemartial>Github</a>
| <a href=https://www.linkedin.com/in/tahirhashmi>LinkedIn</a>
| <a href=https://twitter.com/code_martial>Twitter</a>
| <a href=https://tahirhashmi.com/index.xml>RSS</a>
| &copy; 2022 Tahir Hashmi. All rights reserved.</footer><div class=splash></div></body></html>