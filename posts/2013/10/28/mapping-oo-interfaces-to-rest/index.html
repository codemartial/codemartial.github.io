<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Mapping OO Interfaces to REST, by Tahir Hashmi</title><meta name=description content><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link rel=canonical href=https://tahirhashmi.com/posts/2013/10/28/mapping-oo-interfaces-to-rest/><link rel=alternate type=application/rss+xml href=https://tahirhashmi.com/index.xml><meta property="og:title" content="Mapping OO Interfaces to REST"><meta property="og:description" content="A few days ago, my BBF (Big Boss Forever) Vijay R asked the following question:
Any resources on how to map OO design (controlled state change via methods) to RESTful services? #help
— Vijay Ramachandran (@vijay750) October 24, 2013
Here’s what I think about it. There are a few things that are very different about designing HTTP APIs as compared to language-native implementation design:
The goal of an HTTP API is to minimise coupling and facilitate interoperability, which is less of a concern when the usage environment is restricted to a single programming language and its runtime"><meta property="og:type" content="article"><meta property="og:url" content="https://tahirhashmi.com/posts/2013/10/28/mapping-oo-interfaces-to-rest/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2013-10-28T09:35:46+00:00"><meta property="article:modified_time" content="2022-12-08T08:52:42+07:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Mapping OO Interfaces to REST"><meta name=twitter:description content="A few days ago, my BBF (Big Boss Forever) Vijay R asked the following question:
Any resources on how to map OO design (controlled state change via methods) to RESTful services? #help
— Vijay Ramachandran (@vijay750) October 24, 2013
Here’s what I think about it. There are a few things that are very different about designing HTTP APIs as compared to language-native implementation design:
The goal of an HTTP API is to minimise coupling and facilitate interoperability, which is less of a concern when the usage environment is restricted to a single programming language and its runtime"><meta itemprop=name content="Mapping OO Interfaces to REST"><meta itemprop=description content="A few days ago, my BBF (Big Boss Forever) Vijay R asked the following question:
Any resources on how to map OO design (controlled state change via methods) to RESTful services? #help
— Vijay Ramachandran (@vijay750) October 24, 2013
Here’s what I think about it. There are a few things that are very different about designing HTTP APIs as compared to language-native implementation design:
The goal of an HTTP API is to minimise coupling and facilitate interoperability, which is less of a concern when the usage environment is restricted to a single programming language and its runtime"><meta itemprop=datePublished content="2013-10-28T09:35:46+00:00"><meta itemprop=dateModified content="2022-12-08T08:52:42+07:00"><meta itemprop=wordCount content="516"><meta itemprop=keywords content="Interface Design,REST,webservices,architecture,"><link rel=alternate type=application/rss+xml href=https://tahirhashmi.com/posts/2013/10/28/mapping-oo-interfaces-to-rest/index.xml title="Tahir Hashmi"><link rel=stylesheet href=/assets/css/main.min.734b05aefd7d7d4f6b874ce4bcf84bfed248a56090ac5eea34b8e3a78c883a8a.css media=all><link rel=preload as=font href=/fonts/Probert.woff2 type=font/woff2 crossorigin=anonymous><link rel=preload as=font href=/fonts/ProbertBold.woff2 type=font/woff2 crossorigin=anonymous><link rel=preload as=font href=/fonts/Oxanium.woff2 type=font/woff2 crossorigin=anonymous><link rel=preload as=font href=/fonts/BerkeleyMonoVariable-Regular.woff2 type=font/woff2 crossorigin=anonymous><script defer src=/assets/js/main.min.35e33a864dbe04f338d5c5bb84090b1891b3f1dd3c2b651aa0317abcffc176b5.js></script></head><body class=page><div id=headline><h1>Mapping OO Interfaces to REST</h1></div><div id=content><main><article><time datetime="2013-10-28 09:35:46 +0000 UTC" itemprop=datePublished>October 28, 2013</time><p>A few days ago, my BBF (Big Boss Forever) Vijay R asked the following question:</p><blockquote><p>Any resources on how to map OO design (controlled state change via methods) to RESTful services? <a href="https://twitter.com/search?q=%23help&src=hash" target=_blank>#help</a></p><p>— Vijay Ramachandran (@vijay750) <a href=https://twitter.com/vijay750/statuses/393263875639873537 target=_blank>October 24, 2013</a></p></blockquote><p>Here’s what I think about it. There are a few things that are very different about designing HTTP APIs as compared to language-native <em>implementation</em> design:</p><ol><li><p>The goal of an HTTP API is to minimise coupling and facilitate interoperability, which is less of a concern when the usage environment is restricted to a single programming language and its runtime</p></li><li><p>HTTP APIs must be designed to maximise stability and minimise change over time. On the other hand, implementations must be designed to support business evolution.</p></li><li><p>Implementation design often has a lot of artefacts that result from addressing the constraints of the implementation environment (e.g. GoF Patterns) whereas HTTP APIs usually don’t have a target environment to deal with.</p></li></ol><p>Given the above differences, it’s clear that a 1:1 mapping between a language-native API to an HTTP API will be sub-optimal, unless there is an adapter interface that is designed with the intent of language independent export. The above list of priorities gives some guidelines about how to design such an interface:</p><ol><li><p><strong>Exchange Plain Old Datatypes</strong> or something like C-Structs. This comes from the study of coupling characteristics of software components, which indicates that <a href=http://pages.cpsc.ucalgary.ca/~eberly/Courses/CPSC333/Lectures/Design/coupling.html#data title="CPSC 333: Levels of Coupling" target=_blank>Data Coupling</a> is the most desirable, low level of coupling. Data Coupling, by definition, involves exchange of Plain Old Datatypes.</p></li><li><p><strong>Provide Coarse-grained Methods</strong> that exchange a minimal data “representation” of business resources. Give the clients basic CRUD APIs and hide all validation and business logic behind their implementation. The client should only have to deal with what data they want to save or retrieve, with minimal knowledge of how it is done, other than the rules of business that the client has the liberty to select. This is the essence of Representational State Transfer (REST, yes, that one).</p></li><li><p><strong>Use Ubiquitous Protocols and Wire Formats</strong> since we don’t know whether our API will be consumed by tunnelling middleware (proxies, translators, etc.), dumb end-points (archivers), smart end-points, humans, or even <a href=https://github.com/Netflix/SimianArmy/wiki target=_blank>monkeys</a>, perhaps.</p></li></ol><p>Following the above thought process, it is clear that seeking to directly map a language-native OO interface will result in something more like RPC than a REST interface. There is nothing wrong with RPC – it’s just a different (tighter) level of coupling compared to REST. Whether to directly map the OO API to RPC end-points or provide a more loose data level coupling (or something in-between) then becomes a question of intent – who are we writing the API for.</p><p>After serving the role of an API provider for several years in various projects, I spent the last few years as the consumer of a third party API. I’ve come to believe strongly in the above 3 design principles. A <em>data oriented</em> API with <em>few</em>, <em>uniformly designed</em> methods is the easiest to work with. Most importantly, though, the worst pain that an API provider can inflict on a client is to make them update their code.</p></article><div style=display:flex;width:100%><div style=width:50%><p style=text-align:left>Previous Post:<br><a href=https://tahirhashmi.com/posts/2013/10/28/six-months-with-nikon-d7100/>Six Months with Nikon D7100</a></p></div><div style=width:50%><p style=text-align:right>Next Post:<br><a href=https://tahirhashmi.com/posts/2013/10/31/sensor-format-blind-test/>Sensor Format Blind Test</a></p></div></div></main></div><div id=sidebar><nav class=sidebar-nav><ul><li><a class=sidebar-nav-item href=/posts/ title=Articles>Articles</a></li><li><a class=sidebar-nav-item href=/about/ title=About>About</a></li><li><a class=sidebar-nav-item href=/photos/ title=Photos>Photos</a></li><li><a class=sidebar-nav-item href=/categories/opinion/ title=opinion>opinion</a></li><li><a class=sidebar-nav-item href=/categories/photography/ title=photography>photography</a></li><li><a class=sidebar-nav-item href=/categories/programming/ title=programming>programming</a></li><li><a class=sidebar-nav-item href=/categories/reviews/ title=reviews>reviews</a></li><li><a class=sidebar-nav-item href=/categories/technology/ title=technology>technology</a></li></ul><aside class=toc><h4>On this page</h4><nav id=TableOfContents></nav></aside><div id=fastSearch><span id=cursor><input id=searchInput tabindex=0 placeholder=search></span><ul id=searchResults></ul></div></nav></div><div id=section2><p><a href=https://tahirhashmi.com/posts/>Articles</a></p></div><div id=logo><a href=/><svg id="svgLogo" baseProfile="full" xmlns="https://www.w3.org/2000/svg" viewBox="0 0 400 100" preserveAspectRatio="xMidYMid"><radialGradient id="logoGradient"><stop offset="30%" stop-color="#00ff80"/><stop offset="67%" stop-color="#00c000"/><stop offset="100%" stop-color="#606000"/></radialGradient><polygon points="0, 67 160, 0 200, 100 240, 0 400, 67 240, 33 200, 67 160, 33" fill="url(#logoGradient)"/></svg></a></div><div id=space><p>Tahir Hashmi</p></div><footer id=footer>mail@tahirhashmi.com
| <a href=https://flickr.com/photos/code_martial/>Flickr</a>
| <a href=https://github.com/codemartial>Github</a>
| <a href=https://www.linkedin.com/in/tahirhashmi>LinkedIn</a>
| <a href=https://twitter.com/code_martial>Twitter</a>
| <a href=https://tahirhashmi.com/index.xml>RSS</a>
| &copy; 2022 Tahir Hashmi. All rights reserved.</footer><div class=splash></div><div class=glow></div></body></html>