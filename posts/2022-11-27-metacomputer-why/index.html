<!doctype html><html lang=en-gb><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>The MetaComputer™ (Part "Why" of 3), by Tahir Hashmi</title><meta name=description content="Listing out problems with software development today that lead to the need for a MetaComputer™"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link rel=canonical href=https://tahirhashmi.com/posts/2022-11-27-metacomputer-why/><meta property="og:title" content="The MetaComputer™ (Part &#34;Why&#34; of 3)"><meta property="og:description" content="Listing out problems with software development today that lead to the need for a MetaComputer™"><meta property="og:type" content="article"><meta property="og:url" content="https://tahirhashmi.com/posts/2022-11-27-metacomputer-why/"><meta property="og:image" content="https://live.staticflickr.com/65535/52550325520_2f4962c698_b.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-27T14:26:17+07:00"><meta property="article:modified_time" content="2023-02-16T20:32:59+07:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://live.staticflickr.com/65535/52550325520_2f4962c698_b.jpg"><meta name=twitter:title content="The MetaComputer™ (Part &#34;Why&#34; of 3)"><meta name=twitter:description content="Listing out problems with software development today that lead to the need for a MetaComputer™"><meta itemprop=name content="The MetaComputer™ (Part &#34;Why&#34; of 3)"><meta itemprop=description content="Listing out problems with software development today that lead to the need for a MetaComputer™"><meta itemprop=datePublished content="2022-11-27T14:26:17+07:00"><meta itemprop=dateModified content="2023-02-16T20:32:59+07:00"><meta itemprop=wordCount content="1920"><meta itemprop=image content="https://live.staticflickr.com/65535/52550325520_2f4962c698_b.jpg"><meta itemprop=keywords content><link rel=alternate type=application/rss+xml href=https://tahirhashmi.com/posts/index.xml title="Tahir Hashmi"><link rel=stylesheet href=/assets/css/main.min.9857ebdb77bb5fc08eb13b63f295585ac3d93cb7e69149053482a895118f7636.css media=all><link rel=preload as=font href=/fonts/Probert.woff2 type=font/woff2 crossorigin=anonymous><link rel=preload as=font href=/fonts/ProbertBold.woff2 type=font/woff2 crossorigin=anonymous><link rel=preload as=font href=/fonts/Oxanium.woff2 type=font/woff2 crossorigin=anonymous><link rel=preload as=font href=/fonts/BerkeleyMonoVariable-Regular.woff2 type=font/woff2 crossorigin=anonymous><script defer src=/assets/js/main.min.35e33a864dbe04f338d5c5bb84090b1891b3f1dd3c2b651aa0317abcffc176b5.js></script></head><body class=page><div id=headline><h1>The MetaComputer™ (Part "Why" of 3)</h1></div><div id=content><main><article><time datetime="2022-11-27 14:26:17 +0700 +0700" itemprop=datePublished>November 27, 2022</time><p>It&rsquo;s been a quite a while since I truly enjoyed programming at work. Don&rsquo;t get me wrong. I like wrangling with code to make interesting stuff happen. The problem is that for a long time now, making interesting stuff happen with code hasn&rsquo;t been the end game. Since the last ten years or so, it&rsquo;s become incredibly more complex to get finished code to start working in the real world (aka production). Some say it&rsquo;s because we <a href=https://twitter.com/jasoncwarner/status/1592227285024636928 target=_blank>OD&rsquo;d on microservices</a>. That probably true but there&rsquo;s more to it than that alone.</p><h2 id=of-skyscrapers-and-music>Of Skyscrapers and Music</h2><p>Back in the 1970s the popular opinion among software engineering experts was that software development is like building skyscrapers and bridges. You needed to know exactly what you want to build before you start <del>writing</del> punching code. That led to the (now vilified) waterfall model of software development.</p><p>I believe the waterfall model made sense at that time. The programming was done on bespoke machines that were constructed for corporate customers and were usually housed in the same building as the corporate offices. The customers were all co-located, so they could give immediate feedback if something was broken.</p><p>The challenge was that the cost of producing broken software was pretty high for the programmer. Here&rsquo;s a quote from <a href=https://qr.ae/prX6je target=_blank>someone on Quora</a> about programming on old hardware:</p><blockquote><p>When I started to learn programming as a Physics student in the early 80s, I was sitting in front of a card typewriter and typed my [Fortran] program onto punched cards - one line per card with a maximum of 80 characters. To compile and run my program on a mainframe computer involved taking the stack of cards (never drop them or you will have to manually sort them!) to a card reader and “feed” them into the pre-processing unit.</p><p>The binary version of my program including some cards with some machine instructions was then put into a compile queue and once it was successfully compiled, it was placed into an execution queue. Based on one’s priority, it could take a few minutes or even half a day until your program was executed.</p><p>The output of this entire process was then printed onto “endless” paper tape and placed into an output bin for me to pick up. If I had a syntax or other error in my program, I would get a corresponding error message in my output and I had to start this process from the beginning after correcting the error.</p></blockquote><p>Ouch.</p><p>Things were much better for people who were programming in the 80s through to mid/late 2000s. The computers became interactive, thanks to the attached CRT displays and keyboards. Hardware was a lot more standardised, thanks to the IBM PC. Even if it wasn&rsquo;t, a lot of hardware peculiarities were abstracted by higher level programming languages like C. CPUs used to be single-core. They weren&rsquo;t much too powerful but rapidly gaining strength, as was the available RAM. Floppies and hard disks started appearing for data storage. Also, the Internet was still in its infancy.</p><p>Programmers back then spent most of their time sussing out the most efficient algorithms that would fit in the minuscule quantities of RAM (remember the <a href=https://www.computerworld.com/article/2534312/the--640k--quote-won-t-go-away----but-did-gates-really-say-it-.html target=_blank>640 kB meme</a>?) and run fast enough on the measly compute power of the CPUs of that era.</p><p>This was also the age of <a href=https://www.lawinsider.com/dictionary/shrinkwrap-software target=_blank>shrink-wrapped software</a> where there was a definite end point for software changes before it went to the Floppy/CD masters.</p><p>In a way, this was the best time to be a programmer. The development environment was way less painful and the production environment (customers) were far removed from them, with support tickets being the only channel on which they could be&mldr; bugged.</p><p>This was the time when software engineers decided that they were not construction workers but creative artistes like writers or music composers. They went on to invent concepts like agile development (which later got instutionalised beyond recognition) and <a href=https://en.wikipedia.org/wiki/Extreme_programming target=_blank>eXtreme Programming</a>.</p><p>Ah, these were the <em>good</em> old days that I can vouch for. Also, here&rsquo;s an obligatory quote from Quora:</p><blockquote><p>[Programming in the 80s and 90s] was much less chaotic than it is today. In those days, I programmed in FORTRAN and C using fairly simple toolchains.</p></blockquote><p>Things haven&rsquo;t been the same since. They&rsquo;ve become worse, trust me.</p><h2 id=welcome-to-the-hospitality-business>Welcome to the Hospitality Business</h2><p>By the start of 2010s, two massive developments changed the scene dramatically for the 90s&rsquo; creative programmers.</p><ul><li>Multi-core CPUs with Non-Uniform Memory Architecture</li><li>The Internet as the dominant software delivery channel</li></ul><p>See, back in the 90s and early 2000s, through all the major advancements undergoing mass consumption hardware, the conceptual computer architecture remained constant &ndash; single-threaded x86 CPUs, with single-tier memory model and block storage devices.</p><p>If you doubt the impact that this architecture had on programming, just look at the sheer number of apps for PC/Mac that just don&rsquo;t scale with multi-core CPUs <em>even to this day</em> &ndash; more than 15 years on since the first dual-core Pentium was launched.</p><p>As for the Internet, well, it&rsquo;s been a massive game-changer in software development. The bar for defensive programming has been raised multiple orders of magnitude &ndash; the simplistic 1980s&rsquo; memory abstraction as used in C/C++ is no longer even acceptable.</p><p>Even more significantly, the software distribution model has changed dramatically. The most effective software monetisation model now is SaaS &ndash; Software as a Service &ndash; where you don&rsquo;t ship neatly packed versions of code for others to run on their computers. You run your own code on your own computers and you&rsquo;re responsible for ensuring that it&rsquo;s running flawlessly 24x7x365&mldr; x whatever the age of your company is.</p><p>Welcome to the hospitality business where your customer is a paying visitor to your premises that happen to be located in a dangerous neighbourhood.</p><p>The customer rarely gives you feedback and doesn&rsquo;t like opening support tickets, but always does judge your service &ndash; the speed, the taste, the decor, the safety of your service. And if they don&rsquo;t like your business they&rsquo;d quietly walk away to the business next door that&rsquo;s serving the same cuisine in the same price range but with different decor and cutlery.</p><h2 id=state-of-the-art>State of the Art</h2><p>One consequence of the programming-as-hospitality age is the rise of the &ldquo;full cycle programmer&rdquo;. The programmer doesn&rsquo;t just write code and disconnect. The programmer needs to attend to how the program is running in production and address issues live. You can&rsquo;t shut the restaurant down if a customer throws up between the tables. You isolate the fault and operate around it until it is remedied.</p><p>The full cycle programmer also needs to understand the context in which the program is executing. It&rsquo;s not just the quirks of the immediate computer (server or container), it&rsquo;s the entire topology of distributed services that the application is comprised of.</p><p>Add to this the need to modify the program while still maintaining &ldquo;99.9[9&mldr;]% uptime&rdquo; and things get rather out of hand really fast. Like mentioned in this <a href=https://qr.ae/pGlDaR target=_blank>quora quote</a>:</p><blockquote><p>We have Docker, Kubernetes, AWS, Azure, and a ton of other tools that we must navigate. We have dozens of new languages trying to pull us away from the tried-and-true, for example: Clojure, D, Dart, Elixir, Elm, F#, Go, Haskell, Julia, Kotlin, Lua, OCaml, Rust, Scala, TypeScript, etc.</p><p>And I’ve just barely scratched the surface! It’s all rather overwhelming.</p></blockquote><p>Docker, Kubernetes, tons of other tools and the dozens of new languages are all attempts to cope with the increased demands on security, parallelism and continuous operation.</p><p>However, they&rsquo;re not the solution. They&rsquo;re merely stepping stones towards the solution, which begs the question &ldquo;why do we have this complexity?&rdquo;. The root cause is that we do not have a conceptual model for cloud computing and continuously evolving online services. Developing online software services without that model is like writing a modern desktop application with a programming language that pre-dates C. It&rsquo;s just too complex.</p><p>That&rsquo;s also the reason why I don&rsquo;t enjoy programming as much now. I need to spend way too much effort in wiring together all the components of my distributed topology in a <em>resilient</em>, <em>secure</em> and <em>scalable</em> way. In some ways I can relate to that programmer who was punching Fortran programs onto cards &ndash; way too much effort spent on working the machine, as opposed to having the machine do your work.</p><h2 id=introducing-the-metacomputer>Introducing the MetaComputer™</h2><p>In 1992, the <abbr title="National Centre for Supercomputing Applications">NCSA</abbr> <a href=https://www.researchgate.net/publication/220420706_Metacomputing target=_blank>showcased</a> a &ldquo;Metacomputer&rdquo;, which they defined as follows:</p><blockquote><p>The Metacomputer is a network of heterogeneous, computational resources linked by software in such a way that they can be used as easily as a personal computer.</p></blockquote><p>Nice.</p><p>This was their schematic for the Metacomputer:</p><p><figure><img $destination src=https://live.staticflickr.com/65535/52550325520_2f4962c698_b.jpg alt="NCSA LAN Metacomputer" width=100% style=aspect-ratio:1.6212361331220286><figcaption>NCSA LAN Metacomputer</figcaption></figure></p><p>If you look at it carefully, it&rsquo;s not that hard to extrapolate this schematic towards current cloud environments with neat sections for compute, storage and a web console to access all of these resources. Interestingly, the authors of the NCSA Metacomputer paper only talked at a surface level about the programming model.</p><p>One recent effort I know of that tries to offer a unified metacomputer presentation is <a href=https://mesos.apache.org target=_blank>Apache Mesos</a>. Mesos aspires to be like Linux, except that it runs on a large cluster of machines and offers a unified view into them along with some resource management APIs.</p><p>Unfortunately, that&rsquo;s not the kind of abstration a lot of people really need. The places where Mesos is most applicable is with large scale batch jobs or self-terminating tasks rather than always-on interactive services.</p><p>The other contender is the greek k-word. I mean <a href=https://kubernetes.io target=_blank>kubernetes</a>. Kubernetes promises to solve a lot of problems associated with programming for large scale distributed systems. Unfortunately, it was <a href=https://hackerlife.co/blog/google-san-francisco-phd target=_blank>designed by gods of intellect with lots of PhDs</a> and places a <a href=https://12factor.net target=_blank>very high bar</a> on the intellect of people eligible to write programs for it.</p><p>If you don&rsquo;t believe me, there&rsquo;s a <a href=https://youtu.be/9wvEwPLcLcA target=_blank>Downfall (Hitler) parody</a> for it. There&rsquo;s also a meme about it:<figure><img $destination src=https://miro.medium.com/max/1400/1*3wrB0iUmQfYR9OayrVxECw.webp alt="Once I tried explaining kubernetes to someone. Then we both didn&amp;rsquo;t understand it" width=100% style=aspect-ratio:1.7123287671232876><figcaption>Explaining Kubernetes</figcaption></figure></p><p>Oh actually, there&rsquo;s a <a href=https://twitter.com/memenetes target=_blank>Twitter account</a> full of memes about kubernetes!.</p><p>To be fair, kubernetes is a great piece of engineering that solves many problems related to operating distributed applications in a reliable manner. However, for most developers, it&rsquo;s too <del>large scale</del> low level. Recommending kubernetes as a computing model is like recommending <a href=https://llvm.org target=_blank>LLVM</a> when someone asks for a general purpose programming language. It&rsquo;s not the right level of abstraction.</p><p>Anyway, the point is, the average billion-dollar tech company of today demands a lot from its programming staff and the programmers are still working with an out-dated computing model that were meant for single-threaded non-networked computers.</p><p>This is why we need a new computing model with new conceptual building blocks and new programming models to build applications with them. Not the <abbr title="Infrastructure as Code">IaC</abbr>, or <abbr title="Cloud Development Kit">CDK</abbr> &ndash; they&rsquo;re great for automating infrastructure provisioning and access but that&rsquo;s not really the <em>concern</em> of a programmer, even though it&rsquo;s their responsibility.</p><p>So what is this computing model for, indeed? I&rsquo;ll answer this question in <a href=/posts/2022-12-09-metacomputer-what>The MetaComputer™ (Part &ldquo;What&rdquo; of 3)</a> of this series, coming up next.</p><p>Meanwhile, I&rsquo;d love to invite you to join the <a href=https://github.com/metacomputer target=_blank>MetaComputer™</a> organisation on GitHub to discuss further. The logo of the organisation was generated by DALL·E-2, by the way.</p><p>PS: I didn&rsquo;t include the evolution of front-ends (browsers, mobile apps) because there&rsquo;s not a lot of disconnected apps (i.e. having no &ldquo;backend&rdquo;) so it&rsquo;s inconsequential to the discussion here. I also didn&rsquo;t include the evolution of data storage because SQL and the relational model have held strong as a conceptual model for the last five decades, despite some buzz about NoSQL.</p></article><div style=display:flex;width:100%><div style=width:50%><p style=text-align:left>Previous Post:<br><a href=https://tahirhashmi.com/posts/fujifilm-x-e4/>Fujifilm X-E4: An Engaging Experience I'd Rather Not Have</a></p></div><div style=width:50%><p style=text-align:right>Next Post:<br><a href=https://tahirhashmi.com/posts/2022-12-09-metacomputer-what/>The MetaComputer™ (Part "What" of 3)</a></p></div></div></main></div><div id=sidebar><nav class=sidebar-nav><ul><li><a class=sidebar-nav-item href=/posts/ title=Articles>Articles</a></li><li><a class=sidebar-nav-item href=/about/ title=About>About</a></li><li><a class=sidebar-nav-item href=/photos/ title=Photos>Photos</a></li><li><a class=sidebar-nav-item href=/categories/opinion/ title=opinion>opinion</a></li><li><a class=sidebar-nav-item href=/categories/photography/ title=photography>photography</a></li><li><a class=sidebar-nav-item href=/categories/programming/ title=programming>programming</a></li><li><a class=sidebar-nav-item href=/categories/reviews/ title=reviews>reviews</a></li><li><a class=sidebar-nav-item href=/categories/technology/ title=technology>technology</a></li></ul><aside class=toc><h4>On this page</h4><nav id=TableOfContents><ul><li><a href=#of-skyscrapers-and-music>Of Skyscrapers and Music</a></li><li><a href=#welcome-to-the-hospitality-business>Welcome to the Hospitality Business</a></li><li><a href=#state-of-the-art>State of the Art</a></li><li><a href=#introducing-the-metacomputer>Introducing the MetaComputer™</a></li></ul></nav></aside><div id=fastSearch><span id=cursor><input id=searchInput tabindex=0 placeholder=search></span><ul id=searchResults></ul></div></nav></div><div id=section2><p><a href=https://tahirhashmi.com/posts/>Articles</a></p></div><div id=logo><a href=/><svg id="svgLogo" baseProfile="full" xmlns="https://www.w3.org/2000/svg" viewBox="0 0 400 100" preserveAspectRatio="xMidYMid"><radialGradient id="logoGradient"><stop offset="30%" stop-color="#00ff80"/><stop offset="67%" stop-color="#00c000"/><stop offset="100%" stop-color="#606000"/></radialGradient><polygon points="0, 67 160, 0 200, 100 240, 0 400, 67 240, 33 200, 67 160, 33" fill="url(#logoGradient)"/></svg></a></div><div id=space><p>Tahir Hashmi</p></div><footer id=footer>mail@tahirhashmi.com
| <a href=https://flickr.com/photos/code_martial/>Flickr</a>
| <a href=https://github.com/codemartial>Github</a>
| <a href=https://www.linkedin.com/in/tahirhashmi>LinkedIn</a>
| <a href=https://twitter.com/code_martial>Twitter</a>
| <a href=https://tahirhashmi.com/posts/index.xml type=.mediatype.type rel=.rel>RSS</a> | &copy; 2022 Tahir Hashmi. All rights reserved.</footer><div class=splash></div><div class=glow></div></body></html>